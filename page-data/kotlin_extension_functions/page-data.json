{"componentChunkName":"component---src-components-post-js","path":"/kotlin_extension_functions","result":{"data":{"markdownRemark":{"html":"<p>Kotlin extension functions and properties are similar to member functions/properties, but defined outside of any class.  They let you extend the functionality of a class without having to derive a new class, or use any kind of design pattern.\nThis functionality is helpful when you want to modify classes that you don’t have access to, such as platform api’s or third-party classes.</p>\n<p>For example, take the following Android <code>toast</code> function:</p>\n<pre><code class=\"language-kotlin\">private fun toast(message: String) {\n    Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\n}\n</code></pre>\n<p>In order to create a extension function so that Context can use this toast function, create a new file called <code>Extensions.kt</code> and add the following:</p>\n<pre><code class=\"language-kotlin\">fun Context.toast(message: String) {\n    Toast.makeText(this, message, Toast.LENGTH_LONG).show()\n}\n</code></pre>\n<p>Here we have created an extension function by prefixing the new function with the receiver type, in this case Android’s <code>Context</code> class.</p>\n<p>Now we are able to call <code>toast</code> from any class that extends from Context, such as an Activity or Fragment in Android:</p>\n<pre><code class=\"language-kotlin\">class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        toast(\"Extension functions are awesome!\")\n    }\n}\n</code></pre>\n<p>If we want to add default values for the extension’s parameters, we can specify them in the constructor:</p>\n<pre><code class=\"language-kotlin\">fun Context.toast(message: String, length: Int = Toast.LENGTH_SHORT) {\n    Toast.makeText(this, message, length).show()\n}\n</code></pre>\n<p>And use the extension with a default value, or with a different one:</p>\n<pre><code class=\"language-kotlin\"> toast(\"Extension functions are awesome!\")\n toast(\"Extension functions are awesome!\", Toast.LENGTH_LONG)\n</code></pre>\n<p>Just like extension functions, Kotlin also support extension properties:</p>\n<pre><code class=\"language-kotlin\">val &#x3C;T> List&#x3C;T>.lastIndex: Int\n    get() = size - 1\n</code></pre>\n<p>Extension functions only have access to public properties and functions of the class they are extendingxtension functions do not modify the classes or instances they are extending, but rather make these new functions callable via dot-notation, therefore making their integration with existing classes and objects appear seamless.\nNote that extensions are resolved statically:</p>\n<pre><code class=\"language-kotlin\">open class Vehicle\nclass Truck: Vehicle()\n\nfun Vehicle.getName() = \"Vehicle\"\nfun Truck.getName() = \"Truck\"\n\nfun printClassName(v: Vehicle) {\n    println(v.getName())\n}\n\nprintClassName(Truck())} // prints Vehicle\n</code></pre>\n<p>The above snippet outputs <strong>Vehicle</strong> because the extension function <code>getName()</code> is determined by the declared type of the <code>v</code> parameter, which is of the <code>Vehicle</code> class.</p>\n<p>It would be very easy to use extensions to implement a wide variety abstractions that could make your code a lot harder to understand and mantain, so don’t abuse the power of extension functions.  And remember that static type is resolved at compiled time.</p>\n<p>To learn more, see Kotlin’s official documentation on Extensions <a href=\"https://kotlinlang.org/docs/reference/extensions.html\">Extensions - Kotlin Programming Language</a></p>","frontmatter":{"title":"Kotlin Extension Functions","date":"November 11th, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"pathSlug":"/kotlin_extension_functions"}}}